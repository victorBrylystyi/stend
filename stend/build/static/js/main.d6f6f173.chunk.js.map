{"version":3,"sources":["utils/gltfLoader.js","utils/observable.js","hooks/useAssetsManager.js","components/Model.js","components/Env.js","components/SceneManager.js","index.js"],"names":["loadingManager","THREE","gltfLoader","GLTFLoader","observable","initState","listeners","state","current","get","set","newState","notify","subscribe","fn","indexOf","push","unsubscribe","splice","i","length","cache","textureLoader","LOADING_MODE","isLoaded","path","status","loadAsset","data","usageCount","lastUsedDate","Date","now","Promise","resolve","reject","cacheData","loader","match","toLowerCase","load","model","error","useAssets","paths","useState","assetsToLoad","setAssetsToLoad","useEffect","shouldLoad","filter","assetPath","Boolean","pendingAssets","map","concat","keys","Object","key","currentAsset","cleanUnusedAssets","currentModel","reduce","acc","v","toLoadNext","assets","useMemo","loaded","useAsset","asset","Model","props","meshs","children","scene","traverse","child","isMesh","object","uuid","position","Env","useThree","background","Controls","camera","domElement","ref","useRef","OrbitControls","args","enablePan","enableZoom","enableRotate","SandBox","console","log","gl","SceneManager","pathRim","url","pathStend","color","intensity","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d6f6f173.chunk.js","sourcesContent":["import * as THREE from 'three'\n\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'\n\nconst loadingManager = new THREE.LoadingManager()\nconst gltfLoader = new GLTFLoader(loadingManager)\n\nexport { gltfLoader }","\nconst observable = (initState = {}) => {\n\n    const listeners = []\n    const state = {\n        current: initState\n    }\n\n    const get = () => state.current\n    const set = (newState) => {\n        state.current = newState\n        notify()\n    } \n\n    const subscribe = (fn) => listeners.indexOf(fn) === -1 && listeners.push(fn)\n    const unsubscribe = (fn) => listeners.indexOf(fn) !== -1 && listeners.splice(listeners.indexOf(fn), 1)\n    const notify = () => {\n      for(let i = listeners.length - 1; i >= 0; i--) {\n        let fn = listeners[i]\n        if(!fn) continue\n        fn(state.current)\n      }\n    }\n\n    return {\n        get,\n        set,\n        subscribe,\n        unsubscribe\n    }\n}\n\nexport default observable ","import * as THREE from 'three'\nimport { useEffect, useMemo, useState } from \"react\"\nimport { gltfLoader } from \"../utils/gltfLoader\"\nimport observable from \"../utils/observable\"\n\nexport const cache = observable({})\n\nconst textureLoader = new THREE.TextureLoader()\n\nconst LOADING_MODE = {\n    PENDING: 'PENDING',\n    SUCCESS: 'SUCCESS',\n    ERROR: 'ERROR'\n}\n \nexport const cleanUpCache = () => { \n    cache.set({}) \n}\n\nconst isLoaded = (path) => {\n    const state = cache.get()\n  \n    return (state[path] && state[path].status === LOADING_MODE.SUCCESS)\n}\n\nconst assetExist = (path) => Boolean(cache.get()[path])\n\nconst isAssetPending = (path) => (cache.get()[path] && cache.get()[path].status === LOADING_MODE.PENDING)\n\nconst loadAsset = (path) => {\n\n    if (!path) return Promise.resolve(null)\n\n    const currentCache = cache.get()\n\n    if (!currentCache[path]){\n\n        cache.set(\n            {\n                ...cache.get(),\n                [path]:{\n                    data: null,\n                    status: LOADING_MODE.PENDING,\n                    usageCount: 0, \n                    lastUsedDate: Date.now() \n                }\n            }\n        )\n\n        return new Promise((resolve,reject) => {\n\n            const cacheData = cache.get()\n\n            if (!cacheData[path].data){\n\n                let loader, match, ext\n                const exts = /(\\.(glb|gltf|jpg|jpeg|png))$/gim \n                match = path.match(exts) \n                ext = match[0].toLowerCase()\n                switch (ext) {\n                    case '.gltf':\n                    case '.glb':\n                        loader = gltfLoader\n                    break      \n                    case '.jpg':\n                    case '.jpeg':\n                    case '.png':\n                        loader = textureLoader \n                        break                                               \n                    default:\n                    break\n                }\n                loader.load(\n                    path,\n                    (model) => {\n                        cache.set(\n                            {\n                                ...cache.get(),\n                                [path]: {\n                                    data: model, \n                                    status: LOADING_MODE.SUCCESS,\n                                    usageCount: cacheData[path].usageCount, \n                                    lastUsedDate: cacheData[path].lastUsedDate \n                                }\n                            }\n                        )\n                        resolve(cacheData[path])\n                    },\n                    null,\n                    (error) => {\n                        cache.set(\n                            {\n                                ...cache.get(),\n                                [path]: {\n                                    data: null, \n                                    status: LOADING_MODE.ERROR\n                                }\n                            }\n                        )\n                        reject(error)\n                    }\n                )\n            } else {\n                resolve(cacheData[path])\n            }\n        })\n    }\n\n}\n\nconst cleanUnusedAssets = () => {\n    let keys = Object.keys(cache.get())\n    for(let i = 0; i < keys.length; i++) {\n        let key = keys[i]\n        let currentAsset = cache.get()[key]\n        if(currentAsset.usageCount === 0) {\n            let difference = (Date.now() - currentAsset.lastUsedDate) / 60000\n            if(difference >= 15) {\n                delete cache.get()[key]\n            }\n        }\n    }\n} \n\nexport const useAssets = (paths) => {\n\n    const [assetsToLoad, setAssetsToLoad] = useState(paths || [])\n    \n    /**\n     * Fetch not fetched resources if 'paths' variable was changed\n     */\n\n    useEffect(() => {\n\n        const shouldLoad = paths.filter(assetPath => !assetExist(assetPath))\n        const pendingAssets = paths.filter(assetPath => isAssetPending(assetPath))\n\n        if (shouldLoad.length > 0) {\n            shouldLoad.map(loadAsset) // Fetch here\n        }\n  \n      // Update 'assetsToLoad' to know, how many objects we are waiting for fetch\n        setAssetsToLoad(shouldLoad.concat(pendingAssets))\n        for(let i = 0; i < paths.length; i++) {\n            cache.get()[paths[i]].usageCount += 1\n            cache.get()[paths[i]].lastUsedDate = Date.now()\n        }\n        cleanUnusedAssets()\n        return () => {\n            for(let i = 0; i < paths.length; i++){\n                let currentModel = cache.get()[paths[i]]\n                if(!currentModel) continue\n                currentModel.usageCount -= 1\n            }\n        }\n    }, [paths.reduce((acc, v) => acc + v, '')])\n  \n    /**\n     * Subscribe to cache on mount, remove subscription on unmount\n     */\n\n    useEffect(() => {\n\n        if (assetsToLoad.length === 0) {\n        // If we don't have assetsToLoad then exit\n            return\n        }\n      \n      // Next function is called when some resource has been loaded\n        const fn = () => {\n            // Get resources that haven't fetched yet\n            const toLoadNext = assetsToLoad.filter(assetPath => !isLoaded(assetPath))\n        \n            // If we still have any resources to fetch then update 'assetsToLoad'\n            if (toLoadNext.length !== assetsToLoad.length) {\n                setAssetsToLoad(toLoadNext)\n            }\n        }\n  \n        cache.subscribe(fn)\n  \n        return () => {\n            cache.unsubscribe(fn)\n        }\n\n    }, [assetsToLoad, paths])\n  \n    // This returns our assets\n    const assets = useMemo(() => {\n        const current = cache.get()\n        return paths.filter(isLoaded).map((path) => {\n            return current[path].data\n        })\n    }, [assetsToLoad, paths])\n    \n    return {\n        assets, // Array of loaded assets\n        loaded: (assetsToLoad.length === 0) // Are assets loaded?\n    }\n  }\n  \n\nexport const useAsset = (path) => {\n\n    const { assets, loaded } = useAssets(path ? [path] : [])\n\n    return {\n        asset: assets[0], \n        loaded\n    }\n}\n  ","import { useMemo } from \"react\"\nimport { useAsset } from \"../hooks/useAssetsManager\"\n\n\nconst Model = (props) => {\n\n    const { path } = props\n\n    const { asset } = useAsset(path)\n\n    const meshs = useMemo(()=>{\n        if (asset) {\n            let children = []\n            asset.scene.traverse(child => {\n              if (child.isMesh) {\n                children.push(\n                  <primitive\n                    key={`${child.uuid}`}\n                    object={child}\n                  />\n                )\n              }\n            })\n            return children\n          } else {\n              return []\n          }\n    },[asset])\n\n    return (\n        <group position={[0,0,0]}>\n            {meshs}\n        </group>\n    )\n}\n\nexport default Model","import { useThree } from \"@react-three/fiber\"\nimport { useEffect } from \"react\"\nimport { useAsset } from \"../hooks/useAssetsManager\"\n\n\nconst Env = () => {\n\n    const { asset } = useAsset('./assets/env/fireplace.jpg')\n\n    const get = useThree(state => state.get)\n\n    useEffect(()=>{\n        const { scene } = get()\n\n        scene.background = asset\n    },[asset])\n\n    return null\n\n}\n\nexport default Env","import { OrbitControls } from \"@react-three/drei\"\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\"\nimport { useEffect, useMemo, useRef, useState } from \"react\"\nimport Model from \"./Model\"\nimport Env from \"./Env\"\n\n\n\nconst Controls = ({camera, domElement}) => {\n\n    const ref = useRef()\n\n    // useEffect(()=>{\n    //     console.log(ref)\n    //     ref.current.addEventListener('change',() => console.log('test'))\n    //     return ref.current.removeEventListener('change',() => console.log('test'))\n    // },[])\n\n    // useFrame(()=>{\n    //     ref.current.update()\n    // })\n\n    return (\n        <OrbitControls args={[camera, domElement]} ref={ref} enablePan={true} enableZoom={true} enableRotate={true} />\n    )\n}\n\n\nconst SandBox = ()=>{\n\n    console.log('SandBox')\n\n    const {camera, gl} = useThree()\n\n    return (\n        <Controls camera={camera} domElement={gl.domElement} />\n    )\n}\n\nconst SceneManager = () => {\n\n    const pathRim = useMemo(()=>{\n        return {\n            url:'./assets/models/rim.glb',\n        }\n    },[])\n\n    const pathStend = useMemo(()=>{\n        return {\n            url:'./assets/models/stend.glb',\n        }\n    },[])\n\n    return (\n        <Canvas>\n            <Env />\n            <SandBox />\n            <ambientLight color='white' intensity={1} />\n            <Model path={pathRim.url}/>\n            <Model path={pathStend.url}/>\n        </Canvas>\n    )\n}\n\nexport default SceneManager ","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport SceneManager from './components/SceneManager';\n\nconst App = () => {\n\n    return (\n        <SceneManager />\n    )\n}\n\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}